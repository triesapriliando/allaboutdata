# -*- coding: utf-8 -*-
"""Credit Risk Analysis_Tries Apriliando

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OFN-bBjx3DpzuQSFMu_Hdh9vMrhu8YdJ
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import io

df = pd.read_csv(io.BytesIO(uploaded['loan_data.csv']))
df.head()

df.describe()

df.info()

import seaborn as sns

sns.distplot(df['annual_inc'])

"""Dapat dilihat pada grafik diatas, diketahui bahwa grafik terdistribusi left-skewed atau ekor bergeser kearah kiri. Diketahui bahwa kebanyakan applicant loan memiliki annual income dengan rata-rata 75017"""

cat_data = []
num_data = []

for i,c in enumerate(df.dtypes):
    if c == object:
        cat_data.append(df.iloc[:, i])
    else :
        num_data.append(df.iloc[:, i])

cat_data = pd.DataFrame(cat_data).transpose()
num_data = pd.DataFrame(num_data).transpose()

df = df.dropna(axis='columns', how='all')

df = df.dropna()

x = {'Low Risk': 1}   
df = df.replace(x)

x = dict.fromkeys(['Late (31-120 days)', 'Late (16-30 days)', 'Default', 'In Grace Period'], 'high_risk')    
df = df.replace(x)

df.reset_index(inplace=True, drop=True)

cat_data.head()

df['loan_status'].value_counts()

df['loan_status'].value_counts().plot(kind='bar', color=['r','b'])

"""Berdasarkan data yang telah diselesksi, yaitu data yang digunakan hanya data yang memiliki kelengkapan value untuk setiap column dan row nya. Diketahui bahwa applicant yang terklasifikasi sebagai 'low risk' applicant yaitu sebanyak 815, sedangkan yang terklasifikasi 'high risk' yaitu sebanyak 46 applicant."""

X_df = df.drop(columns=['loan_status'])

X_df = df.drop(columns=['loan_status'])

X_df = df.drop(columns=['desc'])

X = pd.get_dummies(X_df, columns=["url", "pymnt_plan", "issue_d", "last_credit_pull_d", "earliest_cr_line", "last_pymnt_d", "next_pymnt_d", "emp_title", "emp_length", "term", "grade", "sub_grade", "home_ownership", "verification_status", "purpose", "title", "zip_code", "addr_state", "initial_list_status", "application_type"], drop_first = True)

x=pd.get_dummies(x)

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.model_selection import cross_val_score

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1, stratify=y)

LR=LogisticRegression()
LR.fit(X_train,y_train)

pred_cv=LR.predict(X_test)
accuracy_score(y_test,pred_cv)

# Commented out IPython magic to ensure Python compatibility.
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
import statsmodels.api as sm
from statsmodels.formula.api import ols
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import warnings
import numpy as np
import itertools

from imblearn.over_sampling import SMOTE

# %matplotlib inline
warnings.filterwarnings('ignore')

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    #Add Normalization Option
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

cnf_matrix = confusion_matrix(y_test, pred_cv)
plot_confusion_matrix(cnf_matrix, classes=[0,1])

y_test.tail()